# -*- coding: utf-8 -*-
"""Security and Application Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S1dhD3rnYrgUo1Mvmc_ibWRttOQce5ra
"""

import torch
import torch.nn as nn
class HybridAutoencoder(nn.Module):
    def __init__(self):
        super(HybridAutoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(8, 10),
            nn.LeakyReLU(negative_slope=0.5),
            nn.Linear(10, 8)
        )
        self.decoder = nn.Sequential(
            nn.Linear(8, 10),
            nn.LeakyReLU(negative_slope=0.5),
            nn.Linear(10, 8),
            nn.Sigmoid()
        )

    def forward(self, x):
        encoded = self.encoder(x)
        decoded = self.decoder(encoded)
        return decoded
model = HybridAutoencoder()
model.eval()

def load_model(model_path):
    model = HybridAutoencoder()
    model.load_state_dict(torch.load(model_path))
    model.eval()
    return model

def interactive_test(model):
    try:
        user_input = input("Enter an 8-bit binary sequence (e.g., 01010101): ")
        test_input = torch.tensor([[int(bit) for bit in user_input]]).float()
        with torch.no_grad():
            encrypted_vector = model.encoder(test_input)
            print('Encrypted vector:', encrypted_vector.numpy())

            decrypted_vector = model.decoder(encrypted_vector)
            binarized_output = torch.where(decrypted_vector > 0.5, torch.tensor(1.0), torch.tensor(0.0))
            print('Binarized output:', binarized_output.numpy())

    except ValueError:
        print("Invalid input. Please ensure your input is an 8-bit binary sequence.")

def string_to_ascii_binary(input_string):
    """Convert a string to a list of 8-bit binary representations of its ASCII characters."""
    return [format(ord(c), '08b') for c in input_string]

def binary_to_tensor(binary_list):
    """Convert a list of 8-bit binary strings to a tensor."""
    return torch.tensor([[int(bit) for bit in binary] for binary in binary_list], dtype=torch.float)

def tensor_to_binary(tensor):
    """Convert a tensor to a list of binary strings."""
    return [''.join(str(int(bit)) for bit in sequence) for sequence in tensor]

def binary_to_ascii(binary_list):
    """Convert a list of binary strings to their ASCII character equivalents."""
    return ''.join([chr(int(binary, 2)) for binary in binary_list])

if __name__ == "__main__":
    model_path = '/content/drive/MyDrive/SecurityApplicationProject/hybrid_autoencoder_parameters.pth'
    model = load_model(model_path)

    user_input = input("Enter a passage in English: ")
    ascii_binaries = string_to_ascii_binary(user_input)
    input_tensor = binary_to_tensor(ascii_binaries)

    encrypted_vectors = []
    with torch.no_grad():
        for sequence in input_tensor:
            encrypted_vector = model.encoder(sequence.unsqueeze(0))
            encrypted_vectors.append(encrypted_vector)

    decrypted_vectors = []
    for vector in encrypted_vectors:
        decrypted_vector = model.decoder(vector)
        binarized_output = torch.where(decrypted_vector > 0.5, torch.tensor(1.0), torch.tensor(0.0))
        decrypted_vectors.append(binarized_output)

    decrypted_binaries = tensor_to_binary(torch.cat(decrypted_vectors))
    decrypted_text = binary_to_ascii(decrypted_binaries)

    print(f"Original Text: {user_input}")
    print(f"Decrypted Text: {decrypted_text}")

def encrypted_vectors_to_string(encrypted_vectors):
    """Convert encrypted vectors to a string representation."""
    # Convert each tensor in encrypted_vectors to a string of numbers separated by commas
    # and join different vectors with a semicolon for readability
    return '; '.join([', '.join([f'{element:.4f}' for element in vector.squeeze().tolist()]) for vector in encrypted_vectors])

def string_to_encrypted_vectors(encrypted_string):
    """Parse the encrypted string back into a list of tensors."""
    vector_strings = encrypted_string.split('; ')
    vectors = [torch.tensor([float(num) for num in vector.split(', ')], dtype=torch.float).unsqueeze(0) for vector in vector_strings]
    return vectors

def decrypt_encrypted_string(model, encrypted_string):
    """Decrypt an encrypted string back to text."""
    encrypted_vectors = string_to_encrypted_vectors(encrypted_string)
    decrypted_vectors = []
    with torch.no_grad():
        for vector in encrypted_vectors:
            decrypted_vector = model.decoder(vector)
            binarized_output = torch.where(decrypted_vector > 0.5, torch.tensor(1.0), torch.tensor(0.0))
            decrypted_vectors.append(binarized_output)
    decrypted_binaries = tensor_to_binary(torch.cat(decrypted_vectors))
    decrypted_text = binary_to_ascii(decrypted_binaries)
    return decrypted_text


